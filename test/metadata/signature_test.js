// @flow
// eslint-env mocha

const assert = require('assert')
const { before, describe, it } = require('mocha')
const path = require('path')

const { Statement } = require('../../src/model/statement')
const { PublisherId, PrivateSigningKey } = require('../../src/peer/identity')

const CONCAT_PUBLISHER_ID_PUB58 = '4XTTM4JKrrBeAK6qXmo8FoKmT5RkfjeXfZrnWjJNw9fKvPnEs'
const CONCAT_PUBLISHER_ID_PATH = path.join(__dirname, '..', 'resources', 'publisher_ids', 'concat',
  `${CONCAT_PUBLISHER_ID_PUB58}.privateKey`)
const CONCAT_MESSAGE_FIXTURES = require('./../resources/fixtures/concat-message-signature')

describe('Signing', () => {
  let privateKey

  before(() => PrivateSigningKey.fromB58String(
      'K3TgV6BAik881PWHtDC2URuQHWa4xAK6vFMGduwm6jcJhSNAHxeSbYbRUos2qoipFtpsm47Kzu26k9ov1L9tzp6M3nY5o6gGvhmsGvQS22X97EbCCXjEcQAUkBs9DcgsMHnDjHJf'
    ).then(k => { privateKey = k })
  )

  it('calculates a signature for arbitrary statement with a Ed25519 key', () => {
    const stmt = Statement.fromProtobuf({
      id: 'foo',
      publisher: privateKey.publicKey.toB58String(),
      namespace: 'scratch.sig-test',
      timestamp: 1413213180000,
      body: {simple: {object: 'QmF00123', refs: [], deps: [], tags: []}},
      signature: Buffer.from('')
    })
    const expected = '391129a8f48db5f5dcb39882c97a0e98b2a6ffc8ddf5fa2a9b6807d2fc4470826e056aec5d51f3362ca35995a916b3d4301e9431caa295c0a4aaae4e3f9dca0c'
    return stmt.calculateSignature(privateKey)
      .then(signature => assert.equal(signature.toString('hex'), expected, 'signature not as expected'))
  })
})

describe('Signature verification', () => {
  let publisherId

  before(() =>
    PublisherId.generate()
      .then(_pubId => { publisherId = _pubId })
  )

  it('signs and validates a buffer', () => {
    const msg = Buffer.from(`You can get anything you want, at Alice's Restaurant`)
    return publisherId.sign(msg)
      .then(sig => publisherId.verify(msg, sig))
      .then(result => {
        assert(result === true, 'signature did not validate')
      })
  })

  it('does not validate a modified buffer', () => {
    const msg = Buffer.from(`Launch code: 0000`)
    return publisherId.sign(msg)
      .then(sig => publisherId.verify(Buffer.from('Launch code: 0001'), sig))
      .then(result => {
        assert(result === false, 'signature validated an invalid message')
      })
  })

  it('validates a statement made with makeSimpleStatement helper', () => {
    return Statement.createSimple(publisherId, 'scratch.sig-test', {object: 'QmF00123', refs: []})
      .then(stmt => stmt.verifySignature)
      .then(valid => {
        assert(valid, 'statement did not validate')
      })
  })

  it('signs and validates a manually-constructed statement', () => {
    const stmtNoSig = Statement.fromProtobuf({
      id: 'foo',
      publisher: publisherId.id58,
      namespace: 'scratch.sig-test',
      timestamp: Date.now(),
      body: {simple: {object: 'QmF00123', refs: [], deps: [], tags: []}},
      signature: Buffer.from('')
    })
    return stmtNoSig.sign(publisherId)
      .then(signed => signed.verifySignature())
      .then(valid => {
        assert(valid, 'statement did not validate')
      })
  })

  it('does not validate an altered statement', () => {
    Statement.createSimple(publisherId, 'scratch.sig-test', {object: 'QmF00123', refs: []})
      .then(stmt => {
        stmt.namespace = 'scratch.new-namespace'
        return stmt
      })
      .then(altered => altered.verifySignature())
      .then(valid => {
        assert(!valid, 'incorrectly validated an altered statement')
      })
  })

  it('loads a publisher id from a file generated by concat', () => {
    return PublisherId.load(CONCAT_PUBLISHER_ID_PATH)
      .then(id => {
        assert.notEqual(id, null, 'publisher id did not load')
        assert.equal(CONCAT_PUBLISHER_ID_PUB58, id.privateKey.publicKey.toB58String(),
        'base58-encoded public key does not match fixture')
      })
  })

  it('generates the same signature as concat using the same publisher id', () => {
    let privateKey
    return PrivateSigningKey.fromB58String(CONCAT_MESSAGE_FIXTURES.privateKeyB58)
      .then(key => {
        privateKey = key
        assert.equal(privateKey.publicKey.toB58String(), CONCAT_MESSAGE_FIXTURES.publisherIdB58,
        'base58-encoded public key does not match fixture')

        return privateKey.sign(CONCAT_MESSAGE_FIXTURES.message)
      })
      .then(sig => {
        assert.deepEqual(sig, CONCAT_MESSAGE_FIXTURES.signature,
        'signatures did not match')
      })
  })
})
