// @flow
// eslint-env mocha

const assert = require('assert')
const { before, describe, it } = require('mocha')
const path = require('path')

const { Statement } = require('../../src/model/statement')
const { PublisherId, PrivateSigningKey } = require('../../src/peer/identity')
const { signStatement, verifyStatement } = require('../../src/metadata/signatures')

const CONCAT_PUBLISHER_ID_PUB58 = '4XTTM4JKrrBeAK6qXmo8FoKmT5RkfjeXfZrnWjJNw9fKvPnEs'
const CONCAT_PUBLISHER_ID_PATH = path.join(__dirname, '..', 'resources', 'publisher_ids', 'concat',
  `${CONCAT_PUBLISHER_ID_PUB58}.privateKey`)
const CONCAT_MESSAGE_FIXTURES = require('./../resources/fixtures/concat-message-signature')

describe('Signature verification', () => {
  let publisherId

  before(() =>
    PublisherId.generate()
      .then(_pubId => { publisherId = _pubId })
  )

  it('signs and validates a buffer', () => {
    const msg = Buffer.from(`You can get anything you want, at Alice's Restaurant`)
    return publisherId.sign(msg)
      .then(sig => publisherId.verify(msg, sig))
      .then(result => {
        assert(result === true, 'signature did not validate')
      })
  })

  it('does not validate a modified buffer', () => {
    const msg = Buffer.from(`Launch code: 0000`)
    return publisherId.sign(msg)
      .then(sig => publisherId.verify(Buffer.from('Launch code: 0001'), sig))
      .then(result => {
        assert(result === false, 'signature validated an invalid message')
      })
  })

  it('validates a statement made with makeSimpleStatement helper', () => {
    return Statement.createSimple(publisherId, 'scratch.sig-test', {object: 'QmF00123', refs: []})
      .then(stmt => verifyStatement(stmt))
      .then(valid => {
        assert(valid, 'statement did not validate')
      })
  })

  it('signs and validates a manually-constructed statement', () => {
    const stmtNoSig = {
      id: 'foo',
      publisher: publisherId.id58,
      namespace: 'scratch.sig-test',
      timestamp: Date.now(),
      body: {simple: {object: 'QmF00123', refs: [], deps: [], tags: []}},
      signature: Buffer.from('')
    }
    return signStatement(stmtNoSig, publisherId)
      .then(signed => verifyStatement(signed))
      .then(valid => {
        assert(valid, 'statement did not validate')
      })
  })

  it('does not validate an altered statement', () => {
    Statement.createSimple(publisherId, 'scratch.sig-test', {object: 'QmF00123', refs: []})
      .then(stmt => {
        stmt.namespace = 'scratch.new-namespace'
        return stmt
      })
      .then(altered => verifyStatement(altered))
      .then(valid => {
        assert(!valid, 'incorrectly validated an altered statement')
      })
  })

  it('loads a publisher id from a file generated by concat', () => {
    return PublisherId.load(CONCAT_PUBLISHER_ID_PATH)
      .then(id => {
        assert.notEqual(id, null, 'publisher id did not load')
        assert.equal(CONCAT_PUBLISHER_ID_PUB58, id.privateKey.publicKey.toB58String(),
        'base58-encoded public key does not match fixture')
      })
  })

  it('generates the same signature as concat using the same publisher id', () => {
    let privateKey
    return PrivateSigningKey.fromB58String(CONCAT_MESSAGE_FIXTURES.privateKeyB58)
      .then(key => {
        privateKey = key
        assert.equal(privateKey.publicKey.toB58String(), CONCAT_MESSAGE_FIXTURES.publisherIdB58,
        'base58-encoded public key does not match fixture')

        return privateKey.sign(CONCAT_MESSAGE_FIXTURES.message)
      })
      .then(sig => {
        assert.deepEqual(sig, CONCAT_MESSAGE_FIXTURES.signature,
        'signatures did not match')
      })
  })
})
